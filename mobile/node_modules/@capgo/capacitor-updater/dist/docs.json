{
  "api": {
    "name": "CapacitorUpdaterPlugin",
    "slug": "capacitorupdaterplugin",
    "docs": "",
    "tags": [],
    "methods": [
      {
        "name": "notifyAppReady",
        "signature": "() => Promise<AppReadyResult>",
        "parameters": [],
        "returns": "Promise<AppReadyResult>",
        "tags": [
          {
            "name": "returns",
            "text": "Always resolves successfully with current bundle info. This method never fails."
          }
        ],
        "docs": "Notify the native layer that JavaScript initialized successfully.\n\n**CRITICAL: You must call this method on every app launch to prevent automatic rollback.**\n\nThis is a simple notification to confirm that your bundle's JavaScript loaded and executed.\nThe native web server successfully served the bundle files and your JS runtime started.\nThat's all it checks - nothing more complex.\n\n**What triggers rollback:**\n- NOT calling this method within the timeout (default: 10 seconds)\n- Complete JavaScript failure (bundle won't load at all)\n\n**What does NOT trigger rollback:**\n- Runtime errors after initialization (API failures, crashes, etc.)\n- Network request failures\n- Application logic errors\n\n**IMPORTANT: Call this BEFORE any network requests.**\nDon't wait for APIs, data loading, or async operations. Call it as soon as your\nJavaScript bundle starts executing to confirm the bundle itself is valid.\n\nBest practices:\n- Call immediately in your app entry point (main.js, app component mount, etc.)\n- Don't put it after network calls or heavy initialization\n- Don't wrap it in try/catch with conditions\n- Adjust {@link PluginsConfig.CapacitorUpdater.appReadyTimeout} if you need more time",
        "complexTypes": [
          "AppReadyResult"
        ],
        "slug": "notifyappready"
      },
      {
        "name": "setUpdateUrl",
        "signature": "(options: UpdateUrl) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "Contains the URL to use for checking for updates.",
            "type": "UpdateUrl"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options Contains the URL to use for checking for updates."
          },
          {
            "name": "returns",
            "text": "Resolves when the URL is successfully updated."
          },
          {
            "name": "throws",
            "text": "{Error} If `allowModifyUrl` is false or if the operation fails."
          },
          {
            "name": "since",
            "text": "5.4.0"
          }
        ],
        "docs": "Set the update URL for the app dynamically at runtime.\n\nThis overrides the {@link PluginsConfig.CapacitorUpdater.updateUrl} config value.\nRequires {@link PluginsConfig.CapacitorUpdater.allowModifyUrl} to be set to `true`.\n\nUse {@link PluginsConfig.CapacitorUpdater.persistModifyUrl} to persist this value across app restarts.\nOtherwise, the URL will reset to the config value on next app launch.",
        "complexTypes": [
          "UpdateUrl"
        ],
        "slug": "setupdateurl"
      },
      {
        "name": "setStatsUrl",
        "signature": "(options: StatsUrl) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "Contains the URL to use for sending statistics, or an empty string to disable.",
            "type": "StatsUrl"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options Contains the URL to use for sending statistics, or an empty string to disable."
          },
          {
            "name": "returns",
            "text": "Resolves when the URL is successfully updated."
          },
          {
            "name": "throws",
            "text": "{Error} If `allowModifyUrl` is false or if the operation fails."
          },
          {
            "name": "since",
            "text": "5.4.0"
          }
        ],
        "docs": "Set the statistics URL for the app dynamically at runtime.\n\nThis overrides the {@link PluginsConfig.CapacitorUpdater.statsUrl} config value.\nRequires {@link PluginsConfig.CapacitorUpdater.allowModifyUrl} to be set to `true`.\n\nPass an empty string to disable statistics gathering entirely.\nUse {@link PluginsConfig.CapacitorUpdater.persistModifyUrl} to persist this value across app restarts.",
        "complexTypes": [
          "StatsUrl"
        ],
        "slug": "setstatsurl"
      },
      {
        "name": "setChannelUrl",
        "signature": "(options: ChannelUrl) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "Contains the URL to use for channel operations.",
            "type": "ChannelUrl"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options Contains the URL to use for channel operations."
          },
          {
            "name": "returns",
            "text": "Resolves when the URL is successfully updated."
          },
          {
            "name": "throws",
            "text": "{Error} If `allowModifyUrl` is false or if the operation fails."
          },
          {
            "name": "since",
            "text": "5.4.0"
          }
        ],
        "docs": "Set the channel URL for the app dynamically at runtime.\n\nThis overrides the {@link PluginsConfig.CapacitorUpdater.channelUrl} config value.\nRequires {@link PluginsConfig.CapacitorUpdater.allowModifyUrl} to be set to `true`.\n\nUse {@link PluginsConfig.CapacitorUpdater.persistModifyUrl} to persist this value across app restarts.\nOtherwise, the URL will reset to the config value on next app launch.",
        "complexTypes": [
          "ChannelUrl"
        ],
        "slug": "setchannelurl"
      },
      {
        "name": "download",
        "signature": "(options: DownloadOptions) => Promise<BundleInfo>",
        "parameters": [
          {
            "name": "options",
            "docs": "The {@link DownloadOptions} for downloading a new bundle zip.",
            "type": "DownloadOptions"
          }
        ],
        "returns": "Promise<BundleInfo>",
        "tags": [
          {
            "name": "example",
            "text": "const bundle = await CapacitorUpdater.download({\n  url: `https://example.com/versions/${version}/dist.zip`,\n  version: version\n});\n// Bundle is downloaded but not active yet\nawait CapacitorUpdater.next({ id: bundle.id }); // Will activate on next background"
          },
          {
            "name": "param",
            "text": "options The {@link DownloadOptions} for downloading a new bundle zip."
          },
          {
            "name": "returns",
            "text": "The {@link BundleInfo} for the downloaded bundle."
          },
          {
            "name": "throws",
            "text": "{Error} If the download fails or the bundle is invalid."
          }
        ],
        "docs": "Download a new bundle from the provided URL for later installation.\n\nThe downloaded bundle is stored locally but not activated. To use it:\n- Call {@link next} to set it for installation on next app backgrounding/restart\n- Call {@link set} to activate it immediately (destroys current JavaScript context)\n\nThe URL should point to a zip file containing either:\n- Your app files directly in the zip root, or\n- A single folder containing all your app files\n\nThe bundle must include an `index.html` file at the root level.\n\nFor encrypted bundles, provide the `sessionKey` and `checksum` parameters.\nFor multi-file delta updates, provide the `manifest` array.",
        "complexTypes": [
          "BundleInfo",
          "DownloadOptions"
        ],
        "slug": "download"
      },
      {
        "name": "next",
        "signature": "(options: BundleId) => Promise<BundleInfo>",
        "parameters": [
          {
            "name": "options",
            "docs": "Contains the ID of the bundle to set as next. Use {@link BundleInfo.id} from a downloaded bundle.",
            "type": "BundleId"
          }
        ],
        "returns": "Promise<BundleInfo>",
        "tags": [
          {
            "name": "param",
            "text": "options Contains the ID of the bundle to set as next. Use {@link BundleInfo.id} from a downloaded bundle."
          },
          {
            "name": "returns",
            "text": "The {@link BundleInfo} for the specified bundle."
          },
          {
            "name": "throws",
            "text": "{Error} When there is no index.html file inside the bundle folder or the bundle doesn't exist."
          }
        ],
        "docs": "Set the next bundle to be activated when the app backgrounds or restarts.\n\nThis is the recommended way to apply updates as it doesn't interrupt the user's current session.\nThe bundle will be activated when:\n- The app is backgrounded (user switches away), or\n- The app is killed and relaunched, or\n- {@link reload} is called manually\n\nUnlike {@link set}, this method does NOT destroy the current JavaScript context immediately.\nYour app continues running normally until one of the above events occurs.\n\nUse {@link setMultiDelay} to add additional conditions before the update is applied.",
        "complexTypes": [
          "BundleInfo",
          "BundleId"
        ],
        "slug": "next"
      },
      {
        "name": "set",
        "signature": "(options: BundleId) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "A {@link BundleId} object containing the new bundle id to set as current.",
            "type": "BundleId"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options A {@link BundleId} object containing the new bundle id to set as current."
          },
          {
            "name": "returns",
            "text": "A promise that will never resolve because the JavaScript context is destroyed."
          },
          {
            "name": "throws",
            "text": "{Error} When there is no index.html file inside the bundle folder."
          }
        ],
        "docs": "Set the current bundle and immediately reloads the app.\n\n**IMPORTANT: This is a terminal operation that destroys the current JavaScript context.**\n\nWhen you call this method:\n- The entire JavaScript context is immediately destroyed\n- The app reloads from a different folder with different files\n- NO code after this call will execute\n- NO promises will resolve\n- NO callbacks will fire\n- Event listeners registered after this call are unreliable and may never fire\n\nThe reload happens automatically - you don't need to do anything else.\nIf you need to preserve state like the current URL path, use the {@link PluginsConfig.CapacitorUpdater.keepUrlPathAfterReload} config option.\nFor other state preservation needs, save your data before calling this method (e.g., to localStorage).\n\n**Do not** try to execute additional logic after calling `set()` - it won't work as expected.",
        "complexTypes": [
          "BundleId"
        ],
        "slug": "set"
      },
      {
        "name": "delete",
        "signature": "(options: BundleId) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "A {@link BundleId} object containing the bundle ID to delete.",
            "type": "BundleId"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options A {@link BundleId} object containing the bundle ID to delete."
          },
          {
            "name": "returns",
            "text": "Resolves when the bundle is successfully deleted."
          },
          {
            "name": "throws",
            "text": "{Error} If the bundle is currently in use or doesn't exist."
          }
        ],
        "docs": "Delete a bundle from local storage to free up disk space.\n\nYou cannot delete:\n- The currently active bundle\n- The `builtin` bundle (the version shipped with your app)\n- The bundle set as `next` (call {@link next} with a different bundle first)\n\nUse {@link list} to get all available bundle IDs.\n\n**Note:** The bundle ID is NOT the same as the version name.\nUse the `id` field from {@link BundleInfo}, not the `version` field.",
        "complexTypes": [
          "BundleId"
        ],
        "slug": "delete"
      },
      {
        "name": "setBundleError",
        "signature": "(options: BundleId) => Promise<BundleInfo>",
        "parameters": [
          {
            "name": "options",
            "docs": "A {@link BundleId} object containing the bundle ID to mark as errored.",
            "type": "BundleId"
          }
        ],
        "returns": "Promise<BundleInfo>",
        "tags": [
          {
            "name": "param",
            "text": "options A {@link BundleId} object containing the bundle ID to mark as errored."
          },
          {
            "name": "returns",
            "text": "The updated {@link BundleInfo} with status set to `error`."
          },
          {
            "name": "throws",
            "text": "{Error} When the bundle does not exist or `allowManualBundleError` is false."
          },
          {
            "name": "since",
            "text": "7.20.0"
          }
        ],
        "docs": "Manually mark a bundle as failed/errored in manual update mode.\n\nThis is useful when you detect that a bundle has critical issues and want to prevent\nit from being used again. The bundle status will be changed to `error` and the plugin\nwill avoid using this bundle in the future.\n\n**Requirements:**\n- {@link PluginsConfig.CapacitorUpdater.allowManualBundleError} must be set to `true`\n- Only works in manual update mode (when autoUpdate is disabled)\n\nCommon use case: After downloading and testing a bundle, you discover it has critical\nbugs and want to mark it as failed so it won't be retried.",
        "complexTypes": [
          "BundleInfo",
          "BundleId"
        ],
        "slug": "setbundleerror"
      },
      {
        "name": "list",
        "signature": "(options?: ListOptions | undefined) => Promise<BundleListResult>",
        "parameters": [
          {
            "name": "options",
            "docs": "The {@link ListOptions} for customizing the bundle list output.",
            "type": "ListOptions | undefined"
          }
        ],
        "returns": "Promise<BundleListResult>",
        "tags": [
          {
            "name": "param",
            "text": "options The {@link ListOptions} for customizing the bundle list output."
          },
          {
            "name": "returns",
            "text": "A promise containing the array of {@link BundleInfo} objects."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          }
        ],
        "docs": "Get all locally downloaded bundles stored in your app.\n\nThis returns all bundles that have been downloaded and are available locally, including:\n- The currently active bundle\n- The `builtin` bundle (shipped with your app)\n- Any downloaded bundles waiting to be activated\n- Failed bundles (with `error` status)\n\nUse this to:\n- Check available disk space by counting bundles\n- Delete old bundles with {@link delete}\n- Monitor bundle download status",
        "complexTypes": [
          "BundleListResult",
          "ListOptions"
        ],
        "slug": "list"
      },
      {
        "name": "reset",
        "signature": "(options?: ResetOptions | undefined) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "",
            "type": "ResetOptions | undefined"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options"
          },
          {
            "name": "link",
            "text": "ResetOptions} to control reset behavior. If `toLastSuccessful` is `false` (or omitted), resets to builtin. If `true`, resets to last successful bundle."
          },
          {
            "name": "returns",
            "text": "A promise that may never resolve because the app will be reloaded."
          },
          {
            "name": "throws",
            "text": "{Error} If the reset operation fails."
          }
        ],
        "docs": "Reset the app to a known good bundle.\n\nThis method helps recover from problematic updates by reverting to either:\n- The `builtin` bundle (the original version shipped with your app to App Store/Play Store)\n- The last successfully loaded bundle (most recent bundle that worked correctly)\n\n**IMPORTANT: This triggers an immediate app reload, destroying the current JavaScript context.**\nSee {@link set} for details on the implications of this operation.\n\nUse cases:\n- Emergency recovery when an update causes critical issues\n- Testing rollback functionality\n- Providing users a \"reset to factory\" option",
        "complexTypes": [
          "ResetOptions"
        ],
        "slug": "reset"
      },
      {
        "name": "current",
        "signature": "() => Promise<CurrentBundleResult>",
        "parameters": [],
        "returns": "Promise<CurrentBundleResult>",
        "tags": [
          {
            "name": "returns",
            "text": "A promise with the current bundle and native version info."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          }
        ],
        "docs": "Get information about the currently active bundle.\n\nReturns:\n- `bundle`: The currently active bundle information\n- `native`: The version of the builtin bundle (the original app version from App/Play Store)\n\nIf no updates have been applied, `bundle.id` will be `\"builtin\"`, indicating the app\nis running the original version shipped with the native app.\n\nUse this to:\n- Display the current version to users\n- Check if an update is currently active\n- Compare against available updates\n- Log the active bundle for debugging",
        "complexTypes": [
          "CurrentBundleResult"
        ],
        "slug": "current"
      },
      {
        "name": "reload",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "returns",
            "text": "A promise that may never resolve because the app will be reloaded."
          },
          {
            "name": "throws",
            "text": "{Error} If the reload operation fails."
          }
        ],
        "docs": "Manually reload the app to apply a pending update.\n\nThis triggers the same reload behavior that happens automatically when the app backgrounds.\nIf you've called {@link next} to queue an update, calling `reload()` will apply it immediately.\n\n**IMPORTANT: This destroys the current JavaScript context immediately.**\nSee {@link set} for details on the implications of this operation.\n\nCommon use cases:\n- Applying an update immediately after download instead of waiting for backgrounding\n- Providing a \"Restart now\" button to users after an update is ready\n- Testing update flows during development\n\nIf no update is pending (no call to {@link next}), this simply reloads the current bundle.",
        "complexTypes": [],
        "slug": "reload"
      },
      {
        "name": "setMultiDelay",
        "signature": "(options: MultiDelayConditions) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "Contains the {@link MultiDelayConditions} array of conditions.",
            "type": "MultiDelayConditions"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "example",
            "text": "// Update after user kills app OR after 5 minutes in background\nawait CapacitorUpdater.setMultiDelay({\n  delayConditions: [\n    { kind: 'kill' },\n    { kind: 'background', value: '300000' }\n  ]\n});"
          },
          {
            "name": "example",
            "text": "// Update after a specific date\nawait CapacitorUpdater.setMultiDelay({\n  delayConditions: [{ kind: 'date', value: '2025-12-31T23:59:59Z' }]\n});"
          },
          {
            "name": "example",
            "text": "// Default behavior: update on next background\nawait CapacitorUpdater.setMultiDelay({\n  delayConditions: [{ kind: 'background' }]\n});"
          },
          {
            "name": "param",
            "text": "options Contains the {@link MultiDelayConditions} array of conditions."
          },
          {
            "name": "returns",
            "text": "Resolves when the delay conditions are set."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails or conditions are invalid."
          },
          {
            "name": "since",
            "text": "4.3.0"
          }
        ],
        "docs": "Configure conditions that must be met before a pending update is applied.\n\nAfter calling {@link next} to queue an update, use this method to control when it gets applied.\nThe update will only be installed after ALL specified conditions are satisfied.\n\nAvailable condition types:\n- `background`: Wait for the app to be backgrounded. Optionally specify duration in milliseconds.\n- `kill`: Wait for the app to be killed and relaunched (**Note:** Current behavior triggers update immediately on kill, not on next background. This will be fixed in v8.)\n- `date`: Wait until a specific date/time (ISO 8601 format)\n- `nativeVersion`: Wait until the native app is updated to a specific version\n\nCondition value formats:\n- `background`: Number in milliseconds (e.g., `\"300000\"` for 5 minutes), or omit for immediate\n- `kill`: No value needed\n- `date`: ISO 8601 date string (e.g., `\"2025-12-31T23:59:59Z\"`)\n- `nativeVersion`: Version string (e.g., `\"2.0.0\"`)",
        "complexTypes": [
          "MultiDelayConditions"
        ],
        "slug": "setmultidelay"
      },
      {
        "name": "cancelDelay",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "returns",
            "text": "Resolves when the delay conditions are cleared."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "4.0.0"
          }
        ],
        "docs": "Cancel all delay conditions and apply the pending update immediately.\n\nIf you've set delay conditions with {@link setMultiDelay}, this method clears them\nand triggers the pending update to be applied on the next app background or restart.\n\nThis is useful when:\n- User manually requests to update now (e.g., clicks \"Update now\" button)\n- Your app detects it's a good time to update (e.g., user finished critical task)\n- You want to override a time-based delay early",
        "complexTypes": [],
        "slug": "canceldelay"
      },
      {
        "name": "getLatest",
        "signature": "(options?: GetLatestOptions | undefined) => Promise<LatestVersion>",
        "parameters": [
          {
            "name": "options",
            "docs": "Optional {@link GetLatestOptions} to specify which channel to check.",
            "type": "GetLatestOptions | undefined"
          }
        ],
        "returns": "Promise<LatestVersion>",
        "tags": [
          {
            "name": "param",
            "text": "options Optional {@link GetLatestOptions} to specify which channel to check."
          },
          {
            "name": "returns",
            "text": "Information about the latest available bundle version."
          },
          {
            "name": "throws",
            "text": "{Error} Always throws when no new version is available (`error: \"no_new_version_available\"`), or when the request fails."
          },
          {
            "name": "since",
            "text": "4.0.0"
          }
        ],
        "docs": "Check the update server for the latest available bundle version.\n\nThis queries your configured update URL (or Capgo backend) to see if a newer bundle\nis available for download. It does NOT download the bundle automatically.\n\nThe response includes:\n- `version`: The latest available version identifier\n- `url`: Download URL for the bundle (if available)\n- `breaking`: Whether this update is marked as incompatible (requires native app update)\n- `message`: Optional message from the server\n- `manifest`: File list for delta updates (if using multi-file downloads)\n\nAfter receiving the latest version info, you can:\n1. Compare it with your current version\n2. Download it using {@link download}\n3. Apply it using {@link next} or {@link set}\n\n**Important: Error handling for \"no new version available\"**\n\nWhen the device's current version matches the latest version on the server (i.e., the device is already\nup-to-date), the server returns a 200 response with `error: \"no_new_version_available\"` and\n`message: \"No new version available\"`. **This causes `getLatest()` to throw an error**, even though\nthis is a normal, expected condition.\n\nYou should catch this specific error to handle it gracefully:\n\n```typescript\ntry {\n  const latest = await CapacitorUpdater.getLatest();\n  // New version is available, proceed with download\n} catch (error) {\n  if (error.message === 'No new version available') {\n    // Device is already on the latest version - this is normal\n    console.log('Already up to date');\n  } else {\n    // Actual error occurred\n    console.error('Failed to check for updates:', error);\n  }\n}\n```\n\nIn this scenario, the server:\n- Logs the request with a \"No new version available\" message\n- Sends a \"noNew\" stat action to track that the device checked for updates but was already current (done on the backend)",
        "complexTypes": [
          "LatestVersion",
          "GetLatestOptions"
        ],
        "slug": "getlatest"
      },
      {
        "name": "setChannel",
        "signature": "(options: SetChannelOptions) => Promise<ChannelRes>",
        "parameters": [
          {
            "name": "options",
            "docs": "The {@link SetChannelOptions} containing the channel name and optional auto-update trigger.",
            "type": "SetChannelOptions"
          }
        ],
        "returns": "Promise<ChannelRes>",
        "tags": [
          {
            "name": "param",
            "text": "options The {@link SetChannelOptions} containing the channel name and optional auto-update trigger."
          },
          {
            "name": "returns",
            "text": "Channel operation result with status and optional error/message."
          },
          {
            "name": "throws",
            "text": "{Error} If the channel doesn't exist or doesn't allow self-assignment."
          },
          {
            "name": "since",
            "text": "4.7.0"
          }
        ],
        "docs": "Assign this device to a specific update channel at runtime.\n\nChannels allow you to distribute different bundle versions to different groups of users\n(e.g., \"production\", \"beta\", \"staging\"). This method switches the device to a new channel.\n\n**Requirements:**\n- The target channel must allow self-assignment (configured in your Capgo dashboard or backend)\n- The backend may accept or reject the request based on channel settings\n\n**When to use:**\n- After the app is ready and the user has interacted (e.g., opted into beta program)\n- To implement in-app channel switching (beta toggle, tester access, etc.)\n- For user-driven channel changes\n\n**When NOT to use:**\n- At app boot/initialization - use {@link PluginsConfig.CapacitorUpdater.defaultChannel} config instead\n- Before user interaction\n\n**Important: Listen for the `channelPrivate` event**\n\nWhen a user attempts to set a channel that doesn't allow device self-assignment, the method will\nthrow an error AND fire a {@link addListener}('channelPrivate') event. You should listen to this event\nto provide appropriate feedback to users:\n\n```typescript\nCapacitorUpdater.addListener('channelPrivate', (data) => {\n  console.warn(`Cannot access channel \"${data.channel}\": ${data.message}`);\n  // Show user-friendly message\n});\n```\n\nThis sends a request to the Capgo backend linking your device ID to the specified channel.",
        "complexTypes": [
          "ChannelRes",
          "SetChannelOptions"
        ],
        "slug": "setchannel"
      },
      {
        "name": "unsetChannel",
        "signature": "(options: UnsetChannelOptions) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "",
            "type": "UnsetChannelOptions"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options"
          },
          {
            "name": "link",
            "text": "UnsetChannelOptions} containing optional auto-update trigger."
          },
          {
            "name": "returns",
            "text": "Resolves when the channel is successfully unset."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "4.7.0"
          }
        ],
        "docs": "Remove the device's channel assignment and return to the default channel.\n\nThis unlinks the device from any specifically assigned channel, causing it to fall back to:\n- The {@link PluginsConfig.CapacitorUpdater.defaultChannel} if configured, or\n- Your backend's default channel for this app\n\nUse this when:\n- Users opt out of beta/testing programs\n- You want to reset a device to standard update distribution\n- Testing channel switching behavior",
        "complexTypes": [
          "UnsetChannelOptions"
        ],
        "slug": "unsetchannel"
      },
      {
        "name": "getChannel",
        "signature": "() => Promise<GetChannelRes>",
        "parameters": [],
        "returns": "Promise<GetChannelRes>",
        "tags": [
          {
            "name": "returns",
            "text": "The current channel information."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "4.8.0"
          }
        ],
        "docs": "Get the current channel assigned to this device.\n\nReturns information about:\n- `channel`: The currently assigned channel name (if any)\n- `allowSet`: Whether the channel allows self-assignment\n- `status`: Operation status\n- `error`/`message`: Additional information (if applicable)\n\nUse this to:\n- Display current channel to users (e.g., \"You're on the Beta channel\")\n- Check if a device is on a specific channel before showing features\n- Verify channel assignment after calling {@link setChannel}",
        "complexTypes": [
          "GetChannelRes"
        ],
        "slug": "getchannel"
      },
      {
        "name": "listChannels",
        "signature": "() => Promise<ListChannelsResult>",
        "parameters": [],
        "returns": "Promise<ListChannelsResult>",
        "tags": [
          {
            "name": "returns",
            "text": "List of channels the device can self-assign to."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails or the request to the backend fails."
          },
          {
            "name": "since",
            "text": "7.5.0"
          }
        ],
        "docs": "Get a list of all channels available for this device to self-assign to.\n\nOnly returns channels where `allow_self_set` is `true`. These are channels that\nusers can switch to using {@link setChannel} without backend administrator intervention.\n\nEach channel includes:\n- `id`: Unique channel identifier\n- `name`: Human-readable channel name\n- `public`: Whether the channel is publicly visible\n- `allow_self_set`: Always `true` in results (filtered to only self-assignable channels)\n\nUse this to:\n- Build a channel selector UI for users (e.g., \"Join Beta\" button)\n- Show available testing/preview channels\n- Implement channel discovery features",
        "complexTypes": [
          "ListChannelsResult"
        ],
        "slug": "listchannels"
      },
      {
        "name": "setCustomId",
        "signature": "(options: SetCustomIdOptions) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "The {@link SetCustomIdOptions} containing the custom identifier string.",
            "type": "SetCustomIdOptions"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options The {@link SetCustomIdOptions} containing the custom identifier string."
          },
          {
            "name": "returns",
            "text": "Resolves immediately (synchronous operation)."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "4.9.0"
          }
        ],
        "docs": "Set a custom identifier for this device.\n\nThis allows you to identify devices by your own custom ID (user ID, account ID, etc.)\ninstead of or in addition to the device's unique hardware ID. The custom ID is sent\nto your update server and can be used for:\n- Targeting specific users for updates\n- Analytics and user tracking\n- Debugging and support (correlating devices with users)\n- A/B testing or feature flagging\n\n**Persistence:**\n- When {@link PluginsConfig.CapacitorUpdater.persistCustomId} is `true`, the ID persists across app restarts\n- When `false`, the ID is only kept for the current session\n\n**Clearing the custom ID:**\n- Pass an empty string `\"\"` to remove any stored custom ID",
        "complexTypes": [
          "SetCustomIdOptions"
        ],
        "slug": "setcustomid"
      },
      {
        "name": "getBuiltinVersion",
        "signature": "() => Promise<BuiltinVersion>",
        "parameters": [],
        "returns": "Promise<BuiltinVersion>",
        "tags": [
          {
            "name": "returns",
            "text": "The builtin bundle version string."
          },
          {
            "name": "since",
            "text": "5.2.0"
          }
        ],
        "docs": "Get the builtin bundle version (the original version shipped with your native app).\n\nThis returns the version of the bundle that was included when the app was installed\nfrom the App Store or Play Store. This is NOT the currently active bundle version -\nuse {@link current} for that.\n\nReturns:\n- The {@link PluginsConfig.CapacitorUpdater.version} config value if set, or\n- The native app version from platform configs (package.json, Info.plist, build.gradle)\n\nUse this to:\n- Display the \"factory\" version to users\n- Compare against downloaded bundle versions\n- Determine if any updates have been applied\n- Debugging version mismatches",
        "complexTypes": [
          "BuiltinVersion"
        ],
        "slug": "getbuiltinversion"
      },
      {
        "name": "getDeviceId",
        "signature": "() => Promise<DeviceId>",
        "parameters": [],
        "returns": "Promise<DeviceId>",
        "tags": [
          {
            "name": "returns",
            "text": "The unique device identifier string."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          }
        ],
        "docs": "Get the unique, privacy-friendly identifier for this device.\n\nThis ID is used to identify the device when communicating with update servers.\nIt's automatically generated and stored securely by the plugin.\n\n**Privacy & Security characteristics:**\n- Generated as a UUID (not based on hardware identifiers)\n- Stored securely in platform-specific secure storage\n- Android: Android Keystore (persists across app reinstalls on API 23+)\n- iOS: Keychain with `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`\n- Not synced to cloud (iOS)\n- Follows Apple and Google privacy best practices\n- Users can clear it via system settings (Android) or keychain access (iOS)\n\n**Persistence:**\nThe device ID persists across app reinstalls to maintain consistent device identity\nfor update tracking and analytics.\n\nUse this to:\n- Debug update delivery issues (check what ID the server sees)\n- Implement device-specific features\n- Correlate server logs with specific devices",
        "complexTypes": [
          "DeviceId"
        ],
        "slug": "getdeviceid"
      },
      {
        "name": "getPluginVersion",
        "signature": "() => Promise<PluginVersion>",
        "parameters": [],
        "returns": "Promise<PluginVersion>",
        "tags": [
          {
            "name": "returns",
            "text": "The Capacitor Updater plugin version string."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          }
        ],
        "docs": "Get the version of the Capacitor Updater plugin installed in your app.\n\nThis returns the version of the native plugin code (Android/iOS), which is sent\nto the update server with each request. This is NOT your app version or bundle version.\n\nUse this to:\n- Debug plugin-specific issues (when reporting bugs)\n- Verify plugin installation and version\n- Check compatibility with backend features\n- Display in debug/about screens",
        "complexTypes": [
          "PluginVersion"
        ],
        "slug": "getpluginversion"
      },
      {
        "name": "isAutoUpdateEnabled",
        "signature": "() => Promise<AutoUpdateEnabled>",
        "parameters": [],
        "returns": "Promise<AutoUpdateEnabled>",
        "tags": [
          {
            "name": "returns",
            "text": "`true` if auto-update is enabled, `false` if in manual mode."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          }
        ],
        "docs": "Check if automatic updates are currently enabled.\n\nReturns `true` if {@link PluginsConfig.CapacitorUpdater.autoUpdate} is enabled,\nmeaning the plugin will automatically check for, download, and apply updates.\n\nReturns `false` if in manual mode, where you control the update flow using\n{@link getLatest}, {@link download}, {@link next}, and {@link set}.\n\nUse this to:\n- Determine which update flow your app is using\n- Show/hide manual update UI based on mode\n- Debug update behavior",
        "complexTypes": [
          "AutoUpdateEnabled"
        ],
        "slug": "isautoupdateenabled"
      },
      {
        "name": "removeAllListeners",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "returns",
            "text": "Resolves when all listeners are removed."
          },
          {
            "name": "since",
            "text": "1.0.0"
          }
        ],
        "docs": "Remove all event listeners registered for this plugin.\n\nThis unregisters all listeners added via {@link addListener} for all event types:\n- `download`\n- `noNeedUpdate`\n- `updateAvailable`\n- `downloadComplete`\n- `downloadFailed`\n- `breakingAvailable` / `majorAvailable`\n- `updateFailed`\n- `appReloaded`\n- `appReady`\n\nUse this during cleanup (e.g., when unmounting components or closing screens)\nto prevent memory leaks from lingering event listeners.",
        "complexTypes": [],
        "slug": "removealllisteners"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'download', listenerFunc: (state: DownloadEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'download'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: DownloadEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "2.0.11"
          }
        ],
        "docs": "Listen for bundle download event in the App. Fires once a download has started, during downloading and when finished.\nThis will return you all download percent during the download",
        "complexTypes": [
          "PluginListenerHandle",
          "DownloadEvent"
        ],
        "slug": "addlistenerdownload-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'noNeedUpdate', listenerFunc: (state: NoNeedEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'noNeedUpdate'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: NoNeedEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "4.0.0"
          }
        ],
        "docs": "Listen for no need to update event, useful when you want force check every time the app is launched",
        "complexTypes": [
          "PluginListenerHandle",
          "NoNeedEvent"
        ],
        "slug": "addlistenernoneedupdate-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'updateAvailable', listenerFunc: (state: UpdateAvailableEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'updateAvailable'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: UpdateAvailableEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "4.0.0"
          }
        ],
        "docs": "Listen for available update event, useful when you want to force check every time the app is launched",
        "complexTypes": [
          "PluginListenerHandle",
          "UpdateAvailableEvent"
        ],
        "slug": "addlistenerupdateavailable-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'downloadComplete', listenerFunc: (state: DownloadCompleteEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'downloadComplete'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: DownloadCompleteEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "4.0.0"
          }
        ],
        "docs": "Listen for downloadComplete events.",
        "complexTypes": [
          "PluginListenerHandle",
          "DownloadCompleteEvent"
        ],
        "slug": "addlistenerdownloadcomplete-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'breakingAvailable', listenerFunc: (state: BreakingAvailableEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'breakingAvailable'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: MajorAvailableEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "7.22.0"
          }
        ],
        "docs": "Listen for breaking update events when the backend flags an update as incompatible with the current app.\nEmits the same payload as the legacy `majorAvailable` listener.",
        "complexTypes": [
          "PluginListenerHandle",
          "BreakingAvailableEvent"
        ],
        "slug": "addlistenerbreakingavailable-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'majorAvailable', listenerFunc: (state: MajorAvailableEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'majorAvailable'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: MajorAvailableEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "deprecated",
            "text": "Deprecated alias for {@link addListener} with `breakingAvailable`. Emits the same payload. will be removed in v8"
          },
          {
            "name": "since",
            "text": "2.3.0"
          }
        ],
        "docs": "Listen for Major update event in the App, let you know when major update is blocked by setting disableAutoUpdateBreaking",
        "complexTypes": [
          "PluginListenerHandle",
          "MajorAvailableEvent"
        ],
        "slug": "addlistenermajoravailable-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'updateFailed', listenerFunc: (state: UpdateFailedEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'updateFailed'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: UpdateFailedEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "2.3.0"
          }
        ],
        "docs": "Listen for update fail event in the App, let you know when update has fail to install at next app start",
        "complexTypes": [
          "PluginListenerHandle",
          "UpdateFailedEvent"
        ],
        "slug": "addlistenerupdatefailed-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'downloadFailed', listenerFunc: (state: DownloadFailedEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'downloadFailed'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: DownloadFailedEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "4.0.0"
          }
        ],
        "docs": "Listen for download fail event in the App, let you know when a bundle download has failed",
        "complexTypes": [
          "PluginListenerHandle",
          "DownloadFailedEvent"
        ],
        "slug": "addlistenerdownloadfailed-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'appReloaded', listenerFunc: () => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'appReloaded'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "() => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "4.3.0"
          }
        ],
        "docs": "Listen for reload event in the App, let you know when reload has happened",
        "complexTypes": [
          "PluginListenerHandle"
        ],
        "slug": "addlistenerappreloaded-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'appReady', listenerFunc: (state: AppReadyEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'appReady'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: AppReadyEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "5.1.0"
          }
        ],
        "docs": "Listen for app ready event in the App, let you know when app is ready to use, this event is retain till consumed.",
        "complexTypes": [
          "PluginListenerHandle",
          "AppReadyEvent"
        ],
        "slug": "addlistenerappready-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'channelPrivate', listenerFunc: (state: ChannelPrivateEvent) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'channelPrivate'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: ChannelPrivateEvent) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "7.34.0"
          }
        ],
        "docs": "Listen for channel private event, fired when attempting to set a channel that doesn't allow device self-assignment.\n\nThis event is useful for:\n- Informing users they don't have permission to switch to a specific channel\n- Implementing custom error handling for channel restrictions\n- Logging unauthorized channel access attempts",
        "complexTypes": [
          "PluginListenerHandle",
          "ChannelPrivateEvent"
        ],
        "slug": "addlistenerchannelprivate-"
      },
      {
        "name": "addListener",
        "signature": "(eventName: 'onFlexibleUpdateStateChange', listenerFunc: (state: FlexibleUpdateState) => void) => Promise<PluginListenerHandle>",
        "parameters": [
          {
            "name": "eventName",
            "docs": "",
            "type": "'onFlexibleUpdateStateChange'"
          },
          {
            "name": "listenerFunc",
            "docs": "",
            "type": "(state: FlexibleUpdateState) => void"
          }
        ],
        "returns": "Promise<PluginListenerHandle>",
        "tags": [
          {
            "name": "since",
            "text": "8.0.0"
          }
        ],
        "docs": "Listen for flexible update state changes on Android.\n\nThis event fires during the flexible update download process, providing:\n- Download progress (bytes downloaded / total bytes)\n- Installation status changes\n\n**Install status values:**\n- `UNKNOWN` (0): Unknown status\n- `PENDING` (1): Download pending\n- `DOWNLOADING` (2): Download in progress\n- `INSTALLING` (3): Installing the update\n- `INSTALLED` (4): Update installed (app restart needed)\n- `FAILED` (5): Update failed\n- `CANCELED` (6): Update was canceled\n- `DOWNLOADED` (11): Download complete, ready to install\n\nWhen status is `DOWNLOADED`, you should prompt the user and call\n{@link completeFlexibleUpdate} to finish the installation.",
        "complexTypes": [
          "PluginListenerHandle",
          "FlexibleUpdateState"
        ],
        "slug": "addlisteneronflexibleupdatestatechange-"
      },
      {
        "name": "isAutoUpdateAvailable",
        "signature": "() => Promise<AutoUpdateAvailable>",
        "parameters": [],
        "returns": "Promise<AutoUpdateAvailable>",
        "tags": [
          {
            "name": "returns",
            "text": "`false` when custom updateUrl is set, `true` otherwise."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          }
        ],
        "docs": "Check if the auto-update feature is available (not disabled by custom server configuration).\n\nReturns `false` when a custom `updateUrl` is configured, as this typically indicates\nyou're using a self-hosted update server that may not support all auto-update features.\n\nReturns `true` when using the default Capgo backend or when the feature is available.\n\nThis is different from {@link isAutoUpdateEnabled}:\n- `isAutoUpdateEnabled()`: Checks if auto-update MODE is turned on/off\n- `isAutoUpdateAvailable()`: Checks if auto-update is SUPPORTED with your current configuration",
        "complexTypes": [
          "AutoUpdateAvailable"
        ],
        "slug": "isautoupdateavailable"
      },
      {
        "name": "getNextBundle",
        "signature": "() => Promise<BundleInfo | null>",
        "parameters": [],
        "returns": "Promise<BundleInfo | null>",
        "tags": [
          {
            "name": "returns",
            "text": "The pending bundle info, or `null` if none is queued."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "6.8.0"
          }
        ],
        "docs": "Get information about the bundle queued to be activated on next reload.\n\nReturns:\n- {@link BundleInfo} object if a bundle has been queued via {@link next}\n- `null` if no update is pending\n\nThis is useful to:\n- Check if an update is waiting to be applied\n- Display \"Update pending\" status to users\n- Show version info of the queued update\n- Decide whether to show a \"Restart to update\" prompt\n\nThe queued bundle will be activated when:\n- The app is backgrounded (default behavior)\n- The app is killed and restarted\n- {@link reload} is called manually\n- Delay conditions set by {@link setMultiDelay} are met",
        "complexTypes": [
          "BundleInfo"
        ],
        "slug": "getnextbundle"
      },
      {
        "name": "getFailedUpdate",
        "signature": "() => Promise<UpdateFailedEvent | null>",
        "parameters": [],
        "returns": "Promise<UpdateFailedEvent | null>",
        "tags": [
          {
            "name": "returns",
            "text": "The failed update info (cleared after first retrieval), or `null`."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "7.22.0"
          }
        ],
        "docs": "Retrieve information about the most recent bundle that failed to load.\n\nWhen a bundle fails to load (e.g., JavaScript errors prevent initialization, missing files),\nthe plugin automatically rolls back and stores information about the failure. This method\nretrieves that failure information.\n\n**IMPORTANT: The stored value is cleared after being retrieved once.**\nCalling this method multiple times will only return the failure info on the first call,\nthen `null` on subsequent calls until another failure occurs.\n\nReturns:\n- {@link UpdateFailedEvent} with bundle info if a failure was recorded\n- `null` if no failure has occurred or if it was already retrieved\n\nUse this to:\n- Show users why an update failed\n- Log failure information for debugging\n- Implement custom error handling/reporting\n- Display rollback notifications",
        "complexTypes": [
          "UpdateFailedEvent"
        ],
        "slug": "getfailedupdate"
      },
      {
        "name": "setShakeMenu",
        "signature": "(options: SetShakeMenuOptions) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "",
            "type": "SetShakeMenuOptions"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options"
          },
          {
            "name": "link",
            "text": "SetShakeMenuOptions} with `enabled: true` to enable or `enabled: false` to disable."
          },
          {
            "name": "returns",
            "text": "Resolves when the setting is applied."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "7.5.0"
          }
        ],
        "docs": "Enable or disable the shake gesture menu for debugging and testing.\n\nWhen enabled, users can shake their device to open a debug menu that shows:\n- Current bundle information\n- Available bundles\n- Options to switch bundles manually\n- Update status\n\nThis is useful during development and testing to:\n- Quickly test different bundle versions\n- Debug update flows\n- Switch between production and test bundles\n- Verify bundle installations\n\n**Important:** Disable this in production builds or only enable for internal testers.\n\nCan also be configured via {@link PluginsConfig.CapacitorUpdater.shakeMenu}.",
        "complexTypes": [
          "SetShakeMenuOptions"
        ],
        "slug": "setshakemenu"
      },
      {
        "name": "isShakeMenuEnabled",
        "signature": "() => Promise<ShakeMenuEnabled>",
        "parameters": [],
        "returns": "Promise<ShakeMenuEnabled>",
        "tags": [
          {
            "name": "returns",
            "text": "Object with `enabled: true` or `enabled: false`."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "7.5.0"
          }
        ],
        "docs": "Check if the shake gesture debug menu is currently enabled.\n\nReturns the current state of the shake menu feature that can be toggled via\n{@link setShakeMenu} or configured via {@link PluginsConfig.CapacitorUpdater.shakeMenu}.\n\nUse this to:\n- Check if debug features are enabled\n- Show/hide debug settings UI\n- Verify configuration during testing",
        "complexTypes": [
          "ShakeMenuEnabled"
        ],
        "slug": "isshakemenuenabled"
      },
      {
        "name": "setShakeChannelSelector",
        "signature": "(options: SetShakeChannelSelectorOptions) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "",
            "type": "SetShakeChannelSelectorOptions"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options"
          },
          {
            "name": "link",
            "text": "SetShakeChannelSelectorOptions} with `enabled: true` to enable or `enabled: false` to disable."
          },
          {
            "name": "returns",
            "text": "Resolves when the setting is applied."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "8.43.0"
          }
        ],
        "docs": "Enable or disable the shake channel selector at runtime.\n\nWhen enabled AND shakeMenu is true, shaking the device shows a channel\nselector instead of the debug menu. This allows users to switch between\nupdate channels by shaking their device.\n\nAfter selecting a channel, the app automatically checks for updates\nand downloads if available.\n\nCan also be configured via {@link PluginsConfig.CapacitorUpdater.allowShakeChannelSelector}.",
        "complexTypes": [
          "SetShakeChannelSelectorOptions"
        ],
        "slug": "setshakechannelselector"
      },
      {
        "name": "isShakeChannelSelectorEnabled",
        "signature": "() => Promise<ShakeChannelSelectorEnabled>",
        "parameters": [],
        "returns": "Promise<ShakeChannelSelectorEnabled>",
        "tags": [
          {
            "name": "returns",
            "text": "Object with `enabled: true` or `enabled: false`."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "8.43.0"
          }
        ],
        "docs": "Check if the shake channel selector is currently enabled.\n\nReturns the current state of the shake channel selector feature that can be toggled via\n{@link setShakeChannelSelector} or configured via {@link PluginsConfig.CapacitorUpdater.allowShakeChannelSelector}.",
        "complexTypes": [
          "ShakeChannelSelectorEnabled"
        ],
        "slug": "isshakechannelselectorenabled"
      },
      {
        "name": "getAppId",
        "signature": "() => Promise<GetAppIdRes>",
        "parameters": [],
        "returns": "Promise<GetAppIdRes>",
        "tags": [
          {
            "name": "returns",
            "text": "Object containing the current `appId` string."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails."
          },
          {
            "name": "since",
            "text": "7.14.0"
          }
        ],
        "docs": "Get the currently configured App ID used for update server communication.\n\nReturns the App ID that identifies this app to the update server. This can be:\n- The value set via {@link setAppId}, or\n- The {@link PluginsConfig.CapacitorUpdater.appId} config value, or\n- The default app identifier from your native app configuration\n\nUse this to:\n- Verify which App ID is being used for updates\n- Debug update delivery issues\n- Display app configuration in debug screens\n- Confirm App ID after calling {@link setAppId}",
        "complexTypes": [
          "GetAppIdRes"
        ],
        "slug": "getappid"
      },
      {
        "name": "setAppId",
        "signature": "(options: SetAppIdOptions) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "",
            "type": "SetAppIdOptions"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options"
          },
          {
            "name": "link",
            "text": "SetAppIdOptions} containing the new App ID string."
          },
          {
            "name": "returns",
            "text": "Resolves when the App ID is successfully changed."
          },
          {
            "name": "throws",
            "text": "{Error} If `allowModifyAppId` is false or the operation fails."
          },
          {
            "name": "since",
            "text": "7.14.0"
          }
        ],
        "docs": "Dynamically change the App ID used for update server communication.\n\nThis overrides the App ID used to identify your app to the update server, allowing you\nto switch between different app configurations at runtime (e.g., production vs staging\napp IDs, or multi-tenant configurations).\n\n**Requirements:**\n- {@link PluginsConfig.CapacitorUpdater.allowModifyAppId} must be set to `true`\n\n**Important considerations:**\n- Changing the App ID will affect which updates this device receives\n- The new App ID must exist on your update server\n- This is primarily for advanced use cases (multi-tenancy, environment switching)\n- Most apps should use the config-based {@link PluginsConfig.CapacitorUpdater.appId} instead",
        "complexTypes": [
          "SetAppIdOptions"
        ],
        "slug": "setappid"
      },
      {
        "name": "getAppUpdateInfo",
        "signature": "(options?: GetAppUpdateInfoOptions | undefined) => Promise<AppUpdateInfo>",
        "parameters": [
          {
            "name": "options",
            "docs": "Optional {@link GetAppUpdateInfoOptions} with country code for iOS.",
            "type": "GetAppUpdateInfoOptions | undefined"
          }
        ],
        "returns": "Promise<AppUpdateInfo>",
        "tags": [
          {
            "name": "param",
            "text": "options Optional {@link GetAppUpdateInfoOptions} with country code for iOS."
          },
          {
            "name": "returns",
            "text": "Information about the current and available app versions."
          },
          {
            "name": "throws",
            "text": "{Error} If the operation fails or store information is unavailable."
          },
          {
            "name": "since",
            "text": "8.0.0"
          }
        ],
        "docs": "Get information about the app's availability in the App Store or Play Store.\n\nThis method checks the native app stores to see if a newer version of the app\nis available for download. This is different from Capgo's OTA updates - this\nchecks for native app updates that require going through the app stores.\n\n**Platform differences:**\n- **Android**: Uses Play Store's In-App Updates API for accurate update information\n- **iOS**: Queries the App Store lookup API (requires country code for accurate results)\n\n**Returns information about:**\n- Current installed version\n- Available version in the store (if any)\n- Whether an update is available\n- Update priority (Android only)\n- Whether immediate/flexible updates are allowed (Android only)\n\nUse this to:\n- Check if users need to update from the app store\n- Show \"Update Available\" prompts for native updates\n- Implement version gating (require minimum native version)\n- Combine with Capgo OTA updates for a complete update strategy",
        "complexTypes": [
          "AppUpdateInfo",
          "GetAppUpdateInfoOptions"
        ],
        "slug": "getappupdateinfo"
      },
      {
        "name": "openAppStore",
        "signature": "(options?: OpenAppStoreOptions | undefined) => Promise<void>",
        "parameters": [
          {
            "name": "options",
            "docs": "Optional {@link OpenAppStoreOptions} to customize which app's store page to open.",
            "type": "OpenAppStoreOptions | undefined"
          }
        ],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "param",
            "text": "options Optional {@link OpenAppStoreOptions} to customize which app's store page to open."
          },
          {
            "name": "returns",
            "text": "Resolves when the store is opened."
          },
          {
            "name": "throws",
            "text": "{Error} If the store cannot be opened."
          },
          {
            "name": "since",
            "text": "8.0.0"
          }
        ],
        "docs": "Open the app's page in the App Store or Play Store.\n\nThis navigates the user to your app's store listing where they can manually\nupdate the app. Use this as a fallback when in-app updates are not available\nor when the user needs to update on iOS.\n\n**Platform behavior:**\n- **Android**: Opens Play Store to the app's page\n- **iOS**: Opens App Store to the app's page\n\n**Customization options:**\n- `appId`: Specify a custom App Store ID (iOS) - useful for opening a different app's page\n- `packageName`: Specify a custom package name (Android) - useful for opening a different app's page",
        "complexTypes": [
          "OpenAppStoreOptions"
        ],
        "slug": "openappstore"
      },
      {
        "name": "performImmediateUpdate",
        "signature": "() => Promise<AppUpdateResult>",
        "parameters": [],
        "returns": "Promise<AppUpdateResult>",
        "tags": [
          {
            "name": "returns",
            "text": "Result indicating success, cancellation, or failure."
          },
          {
            "name": "throws",
            "text": "{Error} If not on Android, no update is available, or immediate updates not allowed."
          },
          {
            "name": "since",
            "text": "8.0.0"
          }
        ],
        "docs": "Perform an immediate in-app update on Android.\n\nThis triggers Google Play's immediate update flow, which:\n1. Shows a full-screen update UI\n2. Downloads and installs the update\n3. Restarts the app automatically\n\nThe user cannot continue using the app until the update is complete.\nThis is ideal for critical updates that must be installed immediately.\n\n**Requirements:**\n- Android only (throws error on iOS)\n- An update must be available (check with {@link getAppUpdateInfo} first)\n- The update must allow immediate updates (`immediateUpdateAllowed: true`)\n\n**User experience:**\n- Full-screen blocking UI\n- Progress shown during download\n- App automatically restarts after installation",
        "complexTypes": [
          "AppUpdateResult"
        ],
        "slug": "performimmediateupdate"
      },
      {
        "name": "startFlexibleUpdate",
        "signature": "() => Promise<AppUpdateResult>",
        "parameters": [],
        "returns": "Promise<AppUpdateResult>",
        "tags": [
          {
            "name": "returns",
            "text": "Result indicating the update was started, cancelled, or failed."
          },
          {
            "name": "throws",
            "text": "{Error} If not on Android, no update is available, or flexible updates not allowed."
          },
          {
            "name": "since",
            "text": "8.0.0"
          }
        ],
        "docs": "Start a flexible in-app update on Android.\n\nThis triggers Google Play's flexible update flow, which:\n1. Downloads the update in the background\n2. Allows the user to continue using the app\n3. Notifies when download is complete\n4. Requires calling {@link completeFlexibleUpdate} to install\n\nMonitor the download progress using the `onFlexibleUpdateStateChange` listener.\n\n**Requirements:**\n- Android only (throws error on iOS)\n- An update must be available (check with {@link getAppUpdateInfo} first)\n- The update must allow flexible updates (`flexibleUpdateAllowed: true`)\n\n**Typical flow:**\n1. Call `startFlexibleUpdate()` to begin download\n2. Listen to `onFlexibleUpdateStateChange` for progress\n3. When status is `DOWNLOADED`, prompt user to restart\n4. Call `completeFlexibleUpdate()` to install and restart",
        "complexTypes": [
          "AppUpdateResult"
        ],
        "slug": "startflexibleupdate"
      },
      {
        "name": "completeFlexibleUpdate",
        "signature": "() => Promise<void>",
        "parameters": [],
        "returns": "Promise<void>",
        "tags": [
          {
            "name": "returns",
            "text": "Resolves when the update installation begins (app will restart)."
          },
          {
            "name": "throws",
            "text": "{Error} If not on Android or no downloaded update is pending."
          },
          {
            "name": "since",
            "text": "8.0.0"
          }
        ],
        "docs": "Complete a flexible in-app update on Android.\n\nAfter a flexible update has been downloaded (status `DOWNLOADED` in\n`onFlexibleUpdateStateChange`), call this method to install the update\nand restart the app.\n\n**Important:** This will immediately restart the app. Make sure to:\n- Save any user data before calling\n- Prompt the user before restarting\n- Only call when the download status is `DOWNLOADED`",
        "complexTypes": [],
        "slug": "completeflexibleupdate"
      }
    ],
    "properties": []
  },
  "interfaces": [
    {
      "name": "AppReadyResult",
      "slug": "appreadyresult",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "bundle",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo"
        }
      ]
    },
    {
      "name": "BundleInfo",
      "slug": "bundleinfo",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "id",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "version",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "downloaded",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "checksum",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "status",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "BundleStatus"
          ],
          "type": "BundleStatus"
        }
      ]
    },
    {
      "name": "UpdateUrl",
      "slug": "updateurl",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "url",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "StatsUrl",
      "slug": "statsurl",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "url",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "ChannelUrl",
      "slug": "channelurl",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "url",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "DownloadOptions",
      "slug": "downloadoptions",
      "docs": "This URL and versions are used to download the bundle from the server, If you use backend all information will be given by the method getLatest.\nIf you don't use backend, you need to provide the URL and version of the bundle. Checksum and sessionKey are required if you encrypted the bundle with the CLI command encrypt, you should receive them as result of the command.",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "url",
          "tags": [],
          "docs": "The URL of the bundle zip file (e.g: dist.zip) to be downloaded. (This can be any URL. E.g: Amazon S3, a GitHub tag, any other place you've hosted your bundle.)",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "version",
          "tags": [],
          "docs": "The version code/name of this bundle/version",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "sessionKey",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            },
            {
              "text": "undefined",
              "name": "default"
            }
          ],
          "docs": "The session key for the update, when the bundle is encrypted with a session key",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "checksum",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            },
            {
              "text": "undefined",
              "name": "default"
            }
          ],
          "docs": "The checksum for the update, it should be in sha256 and encrypted with private key if the bundle is encrypted",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "manifest",
          "tags": [
            {
              "text": "6.1.0",
              "name": "since"
            },
            {
              "text": "undefined",
              "name": "default"
            }
          ],
          "docs": "The manifest for multi-file downloads",
          "complexTypes": [
            "ManifestEntry"
          ],
          "type": "ManifestEntry[] | undefined"
        }
      ]
    },
    {
      "name": "ManifestEntry",
      "slug": "manifestentry",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "file_name",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | null"
        },
        {
          "name": "file_hash",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | null"
        },
        {
          "name": "download_url",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | null"
        }
      ]
    },
    {
      "name": "BundleId",
      "slug": "bundleid",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "id",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "BundleListResult",
      "slug": "bundlelistresult",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "bundles",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo[]"
        }
      ]
    },
    {
      "name": "ListOptions",
      "slug": "listoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "raw",
          "tags": [
            {
              "text": "6.14.0",
              "name": "since"
            },
            {
              "text": "false",
              "name": "default"
            }
          ],
          "docs": "Whether to return the raw bundle list or the manifest. If true, the list will attempt to read the internal database instead of files on disk.",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    },
    {
      "name": "ResetOptions",
      "slug": "resetoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "toLastSuccessful",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        }
      ]
    },
    {
      "name": "CurrentBundleResult",
      "slug": "currentbundleresult",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "bundle",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo"
        },
        {
          "name": "native",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "MultiDelayConditions",
      "slug": "multidelayconditions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "delayConditions",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "DelayCondition"
          ],
          "type": "DelayCondition[]"
        }
      ]
    },
    {
      "name": "DelayCondition",
      "slug": "delaycondition",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "kind",
          "tags": [
            {
              "text": "value is useless for",
              "name": "param"
            },
            {
              "text": "kind \"kill\", optional for \"background\" (default value: \"0\") and required for \"nativeVersion\" and \"date\"",
              "name": "param"
            }
          ],
          "docs": "Set up delay conditions in setMultiDelay",
          "complexTypes": [
            "DelayUntilNext"
          ],
          "type": "DelayUntilNext"
        },
        {
          "name": "value",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "LatestVersion",
      "slug": "latestversion",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "version",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            }
          ],
          "docs": "Result of getLatest method",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "checksum",
          "tags": [
            {
              "text": "6",
              "name": "since"
            }
          ],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "breaking",
          "tags": [
            {
              "text": "7.22.0",
              "name": "since"
            }
          ],
          "docs": "Indicates whether the update was flagged as breaking by the backend.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "major",
          "tags": [
            {
              "text": "Use {@link LatestVersion.breaking} instead.",
              "name": "deprecated"
            }
          ],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "message",
          "tags": [],
          "docs": "Optional message from the server.\nWhen no new version is available, this will be \"No new version available\".",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "sessionKey",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "error",
          "tags": [],
          "docs": "Error code from the server, if any.\nCommon values:\n- `\"no_new_version_available\"`: Device is already on the latest version (not a failure)\n- Other error codes indicate actual failures in the update process",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "old",
          "tags": [],
          "docs": "The previous/current version name (provided for reference).",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "url",
          "tags": [],
          "docs": "Download URL for the bundle (when a new version is available).",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "manifest",
          "tags": [
            {
              "text": "6.1",
              "name": "since"
            }
          ],
          "docs": "File list for delta updates (when using multi-file downloads).",
          "complexTypes": [
            "ManifestEntry"
          ],
          "type": "ManifestEntry[] | undefined"
        },
        {
          "name": "link",
          "tags": [
            {
              "text": "7.35.0",
              "name": "since"
            }
          ],
          "docs": "Optional link associated with this bundle version (e.g., release notes URL, changelog, GitHub release).",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "comment",
          "tags": [
            {
              "text": "7.35.0",
              "name": "since"
            }
          ],
          "docs": "Optional comment or description for this bundle version.",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "GetLatestOptions",
      "slug": "getlatestoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "channel",
          "tags": [
            {
              "text": "6.8.0",
              "name": "since"
            },
            {
              "text": "undefined",
              "name": "default"
            }
          ],
          "docs": "The channel to get the latest version for\nThe channel must allow 'self_assign' for this to work",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "ChannelRes",
      "slug": "channelres",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "status",
          "tags": [
            {
              "text": "4.7.0",
              "name": "since"
            }
          ],
          "docs": "Current status of set channel",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "error",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "message",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "SetChannelOptions",
      "slug": "setchanneloptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "channel",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "triggerAutoUpdate",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    },
    {
      "name": "UnsetChannelOptions",
      "slug": "unsetchanneloptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "triggerAutoUpdate",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    },
    {
      "name": "GetChannelRes",
      "slug": "getchannelres",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "channel",
          "tags": [
            {
              "text": "4.8.0",
              "name": "since"
            }
          ],
          "docs": "Current status of get channel",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "error",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "message",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "status",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "allowSet",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ]
    },
    {
      "name": "ListChannelsResult",
      "slug": "listchannelsresult",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "channels",
          "tags": [
            {
              "text": "7.5.0",
              "name": "since"
            }
          ],
          "docs": "List of available channels",
          "complexTypes": [
            "ChannelInfo"
          ],
          "type": "ChannelInfo[]"
        }
      ]
    },
    {
      "name": "ChannelInfo",
      "slug": "channelinfo",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "id",
          "tags": [
            {
              "text": "7.5.0",
              "name": "since"
            }
          ],
          "docs": "The channel ID",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "name",
          "tags": [
            {
              "text": "7.5.0",
              "name": "since"
            }
          ],
          "docs": "The channel name",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "public",
          "tags": [
            {
              "text": "7.5.0",
              "name": "since"
            }
          ],
          "docs": "Whether this is a public channel",
          "complexTypes": [],
          "type": "boolean"
        },
        {
          "name": "allow_self_set",
          "tags": [
            {
              "text": "7.5.0",
              "name": "since"
            }
          ],
          "docs": "Whether devices can self-assign to this channel",
          "complexTypes": [],
          "type": "boolean"
        }
      ]
    },
    {
      "name": "SetCustomIdOptions",
      "slug": "setcustomidoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "customId",
          "tags": [],
          "docs": "Custom identifier to associate with the device. Use an empty string to clear any saved value.",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "BuiltinVersion",
      "slug": "builtinversion",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "version",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "DeviceId",
      "slug": "deviceid",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "deviceId",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "PluginVersion",
      "slug": "pluginversion",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "version",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "AutoUpdateEnabled",
      "slug": "autoupdateenabled",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "enabled",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        }
      ]
    },
    {
      "name": "PluginListenerHandle",
      "slug": "pluginlistenerhandle",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "remove",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "() => Promise<void>"
        }
      ]
    },
    {
      "name": "DownloadEvent",
      "slug": "downloadevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "percent",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            }
          ],
          "docs": "Current status of download, between 0 and 100.",
          "complexTypes": [],
          "type": "number"
        },
        {
          "name": "bundle",
          "tags": [],
          "docs": "",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo"
        }
      ]
    },
    {
      "name": "NoNeedEvent",
      "slug": "noneedevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "bundle",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            }
          ],
          "docs": "Current status of download, between 0 and 100.",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo"
        }
      ]
    },
    {
      "name": "UpdateAvailableEvent",
      "slug": "updateavailableevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "bundle",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            }
          ],
          "docs": "Current status of download, between 0 and 100.",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo"
        }
      ]
    },
    {
      "name": "DownloadCompleteEvent",
      "slug": "downloadcompleteevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "bundle",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            }
          ],
          "docs": "Emit when a new update is available.",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo"
        }
      ]
    },
    {
      "name": "MajorAvailableEvent",
      "slug": "majoravailableevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "version",
          "tags": [
            {
              "text": "Deprecated alias for {@link BreakingAvailableEvent}. Receives the same payload.",
              "name": "deprecated"
            },
            {
              "text": "4.0.0",
              "name": "since"
            }
          ],
          "docs": "Emit when a breaking update is available.",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "UpdateFailedEvent",
      "slug": "updatefailedevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "bundle",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            }
          ],
          "docs": "Emit when a update failed to install.",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo"
        }
      ]
    },
    {
      "name": "DownloadFailedEvent",
      "slug": "downloadfailedevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "version",
          "tags": [
            {
              "text": "4.0.0",
              "name": "since"
            }
          ],
          "docs": "Emit when a download fail.",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "AppReadyEvent",
      "slug": "appreadyevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "bundle",
          "tags": [
            {
              "text": "5.2.0",
              "name": "since"
            }
          ],
          "docs": "Emitted when the app is ready to use.",
          "complexTypes": [
            "BundleInfo"
          ],
          "type": "BundleInfo"
        },
        {
          "name": "status",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "ChannelPrivateEvent",
      "slug": "channelprivateevent",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "channel",
          "tags": [
            {
              "text": "7.34.0",
              "name": "since"
            }
          ],
          "docs": "Emitted when attempting to set a channel that doesn't allow device self-assignment.",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "message",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "FlexibleUpdateState",
      "slug": "flexibleupdatestate",
      "docs": "State information for flexible update progress (Android only).",
      "tags": [
        {
          "text": "8.0.0",
          "name": "since"
        }
      ],
      "methods": [],
      "properties": [
        {
          "name": "installStatus",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The current installation status.",
          "complexTypes": [
            "FlexibleUpdateInstallStatus"
          ],
          "type": "FlexibleUpdateInstallStatus"
        },
        {
          "name": "bytesDownloaded",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "Number of bytes downloaded so far.\nOnly available during the `DOWNLOADING` status.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "totalBytesToDownload",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "Total number of bytes to download.\nOnly available during the `DOWNLOADING` status.",
          "complexTypes": [],
          "type": "number | undefined"
        }
      ]
    },
    {
      "name": "AutoUpdateAvailable",
      "slug": "autoupdateavailable",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "available",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        }
      ]
    },
    {
      "name": "SetShakeMenuOptions",
      "slug": "setshakemenuoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "enabled",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        }
      ]
    },
    {
      "name": "ShakeMenuEnabled",
      "slug": "shakemenuenabled",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "enabled",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        }
      ]
    },
    {
      "name": "SetShakeChannelSelectorOptions",
      "slug": "setshakechannelselectoroptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "enabled",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        }
      ]
    },
    {
      "name": "ShakeChannelSelectorEnabled",
      "slug": "shakechannelselectorenabled",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "enabled",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "boolean"
        }
      ]
    },
    {
      "name": "GetAppIdRes",
      "slug": "getappidres",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "appId",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "SetAppIdOptions",
      "slug": "setappidoptions",
      "docs": "",
      "tags": [],
      "methods": [],
      "properties": [
        {
          "name": "appId",
          "tags": [],
          "docs": "",
          "complexTypes": [],
          "type": "string"
        }
      ]
    },
    {
      "name": "AppUpdateInfo",
      "slug": "appupdateinfo",
      "docs": "Information about app updates available in the App Store or Play Store.",
      "tags": [
        {
          "text": "8.0.0",
          "name": "since"
        }
      ],
      "methods": [],
      "properties": [
        {
          "name": "currentVersionName",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The currently installed version name (e.g., \"1.2.3\").",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "availableVersionName",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The version name available in the store, if an update is available.\nMay be undefined if no update information is available.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "currentVersionCode",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The currently installed version code (Android) or build number (iOS).",
          "complexTypes": [],
          "type": "string"
        },
        {
          "name": "availableVersionCode",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The version code available in the store (Android only).\nOn iOS, this will be the same as `availableVersionName`.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "availableVersionReleaseDate",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The release date of the available version (iOS only).\nFormat: ISO 8601 date string.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "updateAvailability",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The current update availability status.",
          "complexTypes": [
            "AppUpdateAvailability"
          ],
          "type": "AppUpdateAvailability"
        },
        {
          "name": "updatePriority",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The priority of the update as set by the developer in Play Console (Android only).\nValues range from 0 (default/lowest) to 5 (highest priority).\n\nUse this to decide whether to show an update prompt or force an update.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "immediateUpdateAllowed",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "Whether an immediate update is allowed (Android only).\n\nIf `true`, you can call {@link CapacitorUpdaterPlugin.performImmediateUpdate}.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "flexibleUpdateAllowed",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "Whether a flexible update is allowed (Android only).\n\nIf `true`, you can call {@link CapacitorUpdaterPlugin.startFlexibleUpdate}.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "clientVersionStalenessDays",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "Number of days since the update became available (Android only).\n\nUse this to implement \"update nagging\" - remind users more frequently\nas the update ages.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "installStatus",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The current install status of a flexible update (Android only).",
          "complexTypes": [
            "FlexibleUpdateInstallStatus"
          ],
          "type": "FlexibleUpdateInstallStatus"
        },
        {
          "name": "minimumOsVersion",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The minimum OS version required for the available update (iOS only).",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "GetAppUpdateInfoOptions",
      "slug": "getappupdateinfooptions",
      "docs": "Options for {@link CapacitorUpdaterPlugin.getAppUpdateInfo}.",
      "tags": [
        {
          "text": "8.0.0",
          "name": "since"
        }
      ],
      "methods": [],
      "properties": [
        {
          "name": "country",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "Two-letter country code (ISO 3166-1 alpha-2) for the App Store lookup.\n\nThis is required on iOS to get accurate App Store information, as app\navailability and versions can vary by country.\n\nExamples: \"US\", \"GB\", \"DE\", \"JP\", \"FR\"\n\nOn Android, this option is ignored as the Play Store handles region\ndetection automatically.",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "OpenAppStoreOptions",
      "slug": "openappstoreoptions",
      "docs": "Options for {@link CapacitorUpdaterPlugin.openAppStore}.",
      "tags": [
        {
          "text": "8.0.0",
          "name": "since"
        }
      ],
      "methods": [],
      "properties": [
        {
          "name": "packageName",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The Android package name to open in the Play Store.\n\nIf not specified, uses the current app's package name.\nUse this to open a different app's store page.\n\nOnly used on Android.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "appId",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The iOS App Store ID to open.\n\nIf not specified, uses the current app's bundle identifier to look up the app.\nUse this to open a different app's store page or when automatic lookup fails.\n\nOnly used on iOS.",
          "complexTypes": [],
          "type": "string | undefined"
        }
      ]
    },
    {
      "name": "AppUpdateResult",
      "slug": "appupdateresult",
      "docs": "Result of an app update operation.",
      "tags": [
        {
          "text": "8.0.0",
          "name": "since"
        }
      ],
      "methods": [],
      "properties": [
        {
          "name": "code",
          "tags": [
            {
              "text": "8.0.0",
              "name": "since"
            }
          ],
          "docs": "The result code of the update operation.",
          "complexTypes": [
            "AppUpdateResultCode"
          ],
          "type": "AppUpdateResultCode"
        }
      ]
    }
  ],
  "enums": [
    {
      "name": "FlexibleUpdateInstallStatus",
      "slug": "flexibleupdateinstallstatus",
      "members": [
        {
          "name": "UNKNOWN",
          "value": "0",
          "tags": [],
          "docs": "Unknown install status."
        },
        {
          "name": "PENDING",
          "value": "1",
          "tags": [],
          "docs": "Download is pending and will start soon."
        },
        {
          "name": "DOWNLOADING",
          "value": "2",
          "tags": [],
          "docs": "Download is in progress.\nCheck `bytesDownloaded` and `totalBytesToDownload` for progress."
        },
        {
          "name": "INSTALLING",
          "value": "3",
          "tags": [],
          "docs": "The update is being installed."
        },
        {
          "name": "INSTALLED",
          "value": "4",
          "tags": [],
          "docs": "The update has been installed.\nThe app needs to be restarted to use the new version."
        },
        {
          "name": "FAILED",
          "value": "5",
          "tags": [],
          "docs": "The update failed to download or install."
        },
        {
          "name": "CANCELED",
          "value": "6",
          "tags": [],
          "docs": "The update was canceled by the user."
        },
        {
          "name": "DOWNLOADED",
          "value": "11",
          "tags": [],
          "docs": "The update has been downloaded and is ready to install.\nCall {@link CapacitorUpdaterPlugin.completeFlexibleUpdate} to install."
        }
      ]
    },
    {
      "name": "AppUpdateAvailability",
      "slug": "appupdateavailability",
      "members": [
        {
          "name": "UNKNOWN",
          "value": "0",
          "tags": [],
          "docs": "Update availability is unknown.\nThis typically means the check hasn't completed or failed."
        },
        {
          "name": "UPDATE_NOT_AVAILABLE",
          "value": "1",
          "tags": [],
          "docs": "No update is available.\nThe installed version is the latest."
        },
        {
          "name": "UPDATE_AVAILABLE",
          "value": "2",
          "tags": [],
          "docs": "An update is available for download."
        },
        {
          "name": "UPDATE_IN_PROGRESS",
          "value": "3",
          "tags": [],
          "docs": "An update is currently being downloaded or installed."
        }
      ]
    },
    {
      "name": "AppUpdateResultCode",
      "slug": "appupdateresultcode",
      "members": [
        {
          "name": "OK",
          "value": "0",
          "tags": [],
          "docs": "The update completed successfully."
        },
        {
          "name": "CANCELED",
          "value": "1",
          "tags": [],
          "docs": "The user canceled the update."
        },
        {
          "name": "FAILED",
          "value": "2",
          "tags": [],
          "docs": "The update failed."
        },
        {
          "name": "NOT_AVAILABLE",
          "value": "3",
          "tags": [],
          "docs": "No update is available."
        },
        {
          "name": "NOT_ALLOWED",
          "value": "4",
          "tags": [],
          "docs": "The requested update type is not allowed.\nFor example, trying to perform an immediate update when only flexible is allowed."
        },
        {
          "name": "INFO_MISSING",
          "value": "5",
          "tags": [],
          "docs": "Required information is missing.\nThis can happen if {@link CapacitorUpdaterPlugin.getAppUpdateInfo} wasn't called first."
        }
      ]
    }
  ],
  "typeAliases": [
    {
      "name": "BundleStatus",
      "slug": "bundlestatus",
      "docs": "pending: The bundle is pending to be **SET** as the next bundle.\ndownloading: The bundle is being downloaded.\nsuccess: The bundle has been downloaded and is ready to be **SET** as the next bundle.\nerror: The bundle has failed to download.",
      "types": [
        {
          "text": "'success'",
          "complexTypes": []
        },
        {
          "text": "'error'",
          "complexTypes": []
        },
        {
          "text": "'pending'",
          "complexTypes": []
        },
        {
          "text": "'downloading'",
          "complexTypes": []
        }
      ]
    },
    {
      "name": "DelayUntilNext",
      "slug": "delayuntilnext",
      "docs": "",
      "types": [
        {
          "text": "'background'",
          "complexTypes": []
        },
        {
          "text": "'kill'",
          "complexTypes": []
        },
        {
          "text": "'nativeVersion'",
          "complexTypes": []
        },
        {
          "text": "'date'",
          "complexTypes": []
        }
      ]
    },
    {
      "name": "BreakingAvailableEvent",
      "slug": "breakingavailableevent",
      "docs": "Payload emitted by {@link CapacitorUpdaterPlugin.addListener} with `breakingAvailable`.",
      "types": [
        {
          "text": "MajorAvailableEvent",
          "complexTypes": [
            "MajorAvailableEvent"
          ]
        }
      ]
    }
  ],
  "pluginConfigs": [
    {
      "name": "CapacitorUpdater",
      "slug": "capacitorupdater",
      "properties": [
        {
          "name": "appReadyTimeout",
          "tags": [
            {
              "text": "10000 // (10 seconds)",
              "name": "default"
            },
            {
              "text": "1000 // (1 second, minimum 1000)",
              "name": "example"
            }
          ],
          "docs": "Configure the number of milliseconds the native plugin should wait before considering an update 'failed'.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "responseTimeout",
          "tags": [
            {
              "text": "20 // (20 second)",
              "name": "default"
            },
            {
              "text": "10 // (10 second)",
              "name": "example"
            }
          ],
          "docs": "Configure the number of seconds the native plugin should wait before considering API timeout.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "autoDeleteFailed",
          "tags": [
            {
              "text": "true",
              "name": "default"
            },
            {
              "text": "false",
              "name": "example"
            }
          ],
          "docs": "Configure whether the plugin should use automatically delete failed bundles.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "autoDeletePrevious",
          "tags": [
            {
              "text": "true",
              "name": "default"
            },
            {
              "text": "false",
              "name": "example"
            }
          ],
          "docs": "Configure whether the plugin should use automatically delete previous bundles after a successful update.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "autoUpdate",
          "tags": [
            {
              "text": "true",
              "name": "default"
            },
            {
              "text": "false",
              "name": "example"
            }
          ],
          "docs": "Configure whether the plugin should use Auto Update via an update server.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "resetWhenUpdate",
          "tags": [
            {
              "text": "true",
              "name": "default"
            },
            {
              "text": "false",
              "name": "example"
            }
          ],
          "docs": "Automatically delete previous downloaded bundles when a newer native app bundle is installed to the device.\nSetting this to false can broke the auto update flow if the user download from the store a native app bundle that is older than the current downloaded bundle. Upload will be prevented by channel setting downgrade_under_native.\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "updateUrl",
          "tags": [
            {
              "text": "https://plugin.capgo.app/updates",
              "name": "default"
            },
            {
              "text": "https://example.com/api/auto_update",
              "name": "example"
            }
          ],
          "docs": "Configure the URL / endpoint to which update checks are sent.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "channelUrl",
          "tags": [
            {
              "text": "https://plugin.capgo.app/channel_self",
              "name": "default"
            },
            {
              "text": "https://example.com/api/channel",
              "name": "example"
            }
          ],
          "docs": "Configure the URL / endpoint for channel operations.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "statsUrl",
          "tags": [
            {
              "text": "https://plugin.capgo.app/stats",
              "name": "default"
            },
            {
              "text": "https://example.com/api/stats",
              "name": "example"
            }
          ],
          "docs": "Configure the URL / endpoint to which update statistics are sent.\n\nOnly available for Android and iOS. Set to \"\" to disable stats reporting.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "publicKey",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "6.2.0",
              "name": "since"
            }
          ],
          "docs": "Configure the public key for end to end live update encryption Version 2\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "version",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "4.17.48",
              "name": "since"
            }
          ],
          "docs": "Configure the current version of the app. This will be used for the first update request.\nIf not set, the plugin will get the version from the native code.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "directUpdate",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "5.1.0",
              "name": "since"
            }
          ],
          "docs": "Configure when the plugin should direct install updates. Only for autoUpdate mode.\nWorks well for apps less than 10MB and with uploads done using --delta flag.\nZip or apps more than 10MB will be relatively slow for users to update.\n- false: Never do direct updates (use default behavior: download at start, set when backgrounded)\n- atInstall: Direct update only when app is installed, updated from store, otherwise act as directUpdate = false\n- onLaunch: Direct update only on app installed, updated from store or after app kill, otherwise act as directUpdate = false\n- always: Direct update in all previous cases (app installed, updated from store, after app kill or app resume), never act as directUpdate = false\n- true: (deprecated) Same as \"always\" for backward compatibility\n\nActivate this flag will automatically make the CLI upload delta in CICD envs and will ask for confirmation in local uploads.\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | 'always' | 'atInstall' | 'onLaunch' | undefined"
        },
        {
          "name": "autoSplashscreen",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "7.6.0",
              "name": "since"
            }
          ],
          "docs": "Automatically handle splashscreen hiding when using directUpdate. When enabled, the plugin will automatically hide the splashscreen after updates are applied or when no update is needed.\nThis removes the need to manually listen for appReady events and call SplashScreen.hide().\nOnly works when directUpdate is set to \"atInstall\", \"always\", \"onLaunch\", or true.\nRequires the @capacitor/splash-screen plugin to be installed and configured with launchAutoHide: false.\nRequires autoUpdate and directUpdate to be enabled.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "autoSplashscreenLoader",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "7.19.0",
              "name": "since"
            }
          ],
          "docs": "Display a native loading indicator on top of the splashscreen while automatic direct updates are running.\nOnly takes effect when {@link autoSplashscreen} is enabled.\nRequires the @capacitor/splash-screen plugin to be installed and configured with launchAutoHide: false.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "autoSplashscreenTimeout",
          "tags": [
            {
              "text": "10000 // (10 seconds)",
              "name": "default"
            },
            {
              "text": "7.19.0",
              "name": "since"
            }
          ],
          "docs": "Automatically hide the splashscreen after the specified number of milliseconds when using automatic direct updates.\nIf the timeout elapses, the update continues to download in the background while the splashscreen is dismissed.\nSet to `0` (zero) to disable the timeout.\nWhen the timeout fires, the direct update flow is skipped and the downloaded bundle is installed on the next background/launch.\nRequires {@link autoSplashscreen} to be enabled.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "periodCheckDelay",
          "tags": [
            {
              "text": "0 (disabled)",
              "name": "default"
            },
            {
              "text": "3600 (1 hour)",
              "name": "example"
            },
            {
              "text": "86400 (24 hours)",
              "name": "example"
            }
          ],
          "docs": "Configure the delay period for period update check. the unit is in seconds.\n\nOnly available for Android and iOS.\nCannot be less than 600 seconds (10 minutes).",
          "complexTypes": [],
          "type": "number | undefined"
        },
        {
          "name": "localS3",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "4.17.48",
              "name": "since"
            }
          ],
          "docs": "Configure the CLI to use a local server for testing or self-hosted update server.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "localHost",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "4.17.48",
              "name": "since"
            }
          ],
          "docs": "Configure the CLI to use a local server for testing or self-hosted update server.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "localWebHost",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "4.17.48",
              "name": "since"
            }
          ],
          "docs": "Configure the CLI to use a local server for testing or self-hosted update server.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "localSupa",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "4.17.48",
              "name": "since"
            }
          ],
          "docs": "Configure the CLI to use a local server for testing or self-hosted update server.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "localSupaAnon",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "4.17.48",
              "name": "since"
            }
          ],
          "docs": "Configure the CLI to use a local server for testing.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "localApi",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "6.3.3",
              "name": "since"
            }
          ],
          "docs": "Configure the CLI to use a local api for testing.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "localApiFiles",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "6.3.3",
              "name": "since"
            }
          ],
          "docs": "Configure the CLI to use a local file api for testing.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "allowModifyUrl",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "5.4.0",
              "name": "since"
            }
          ],
          "docs": "Allow the plugin to modify the updateUrl, statsUrl and channelUrl dynamically from the JavaScript side.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "allowModifyAppId",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "7.14.0",
              "name": "since"
            }
          ],
          "docs": "Allow the plugin to modify the appId dynamically from the JavaScript side.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "allowManualBundleError",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "7.20.0",
              "name": "since"
            }
          ],
          "docs": "Allow marking bundles as errored from JavaScript while using manual update flows.\nWhen enabled, {@link CapacitorUpdaterPlugin.setBundleError} can change a bundle status to `error`.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "persistCustomId",
          "tags": [
            {
              "text": "false (will be true by default in a future major release v8.x.x)",
              "name": "default"
            },
            {
              "text": "7.17.3",
              "name": "since"
            }
          ],
          "docs": "Persist the customId set through {@link CapacitorUpdaterPlugin.setCustomId} across app restarts.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "persistModifyUrl",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "7.20.0",
              "name": "since"
            }
          ],
          "docs": "Persist the updateUrl, statsUrl and channelUrl set through {@link CapacitorUpdaterPlugin.setUpdateUrl},\n{@link CapacitorUpdaterPlugin.setStatsUrl} and {@link CapacitorUpdaterPlugin.setChannelUrl} across app restarts.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "allowSetDefaultChannel",
          "tags": [
            {
              "text": "true",
              "name": "default"
            },
            {
              "text": "7.34.0",
              "name": "since"
            }
          ],
          "docs": "Allow or disallow the {@link CapacitorUpdaterPlugin.setChannel} method to modify the defaultChannel.\nWhen set to `false`, calling `setChannel()` will return an error with code `disabled_by_config`.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "defaultChannel",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "5.5.0",
              "name": "since"
            }
          ],
          "docs": "Set the default channel for the app in the config. Case sensitive.\nThis will setting will override the default channel set in the cloud, but will still respect overrides made in the cloud.\nThis requires the channel to allow devices to self dissociate/associate in the channel settings. https://capgo.app/docs/public-api/channels/#channel-configuration-options",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "appId",
          "tags": [
            {
              "text": "undefined",
              "name": "default"
            },
            {
              "text": "6.0.0",
              "name": "since"
            }
          ],
          "docs": "Configure the app id for the app in the config.",
          "complexTypes": [],
          "type": "string | undefined"
        },
        {
          "name": "keepUrlPathAfterReload",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "6.8.0",
              "name": "since"
            }
          ],
          "docs": "Configure the plugin to keep the URL path after a reload.\nWARNING: When a reload is triggered, 'window.history' will be cleared.",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "disableJSLogging",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "7.3.0",
              "name": "since"
            }
          ],
          "docs": "Disable the JavaScript logging of the plugin. if true, the plugin will not log to the JavaScript console. only the native log will be done",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "osLogging",
          "tags": [
            {
              "text": "true",
              "name": "default"
            },
            {
              "text": "8.42.0",
              "name": "since"
            }
          ],
          "docs": "Enable OS-level logging. When enabled, logs are written to the system log which can be inspected in production builds.\n\n- **iOS**: Uses os_log instead of Swift.print, logs accessible via Console.app or Instruments\n- **Android**: Logs to Logcat (android.util.Log)\n\nWhen set to false, system logging is disabled on both platforms (only JavaScript console logging will occur if enabled).\n\nThis is useful for debugging production apps (App Store/TestFlight builds on iOS, or production APKs on Android).",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "shakeMenu",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "7.5.0",
              "name": "since"
            }
          ],
          "docs": "Enable shake gesture to show update menu for debugging/testing purposes",
          "complexTypes": [],
          "type": "boolean | undefined"
        },
        {
          "name": "allowShakeChannelSelector",
          "tags": [
            {
              "text": "false",
              "name": "default"
            },
            {
              "text": "8.43.0",
              "name": "since"
            }
          ],
          "docs": "Enable the shake gesture to show a channel selector menu for switching between update channels.\nWhen enabled AND `shakeMenu` is true, the shake gesture shows a channel selector\ninstead of the default debug menu (Go Home/Reload/Close).\n\nAfter selecting a channel, the app automatically checks for updates and downloads if available.\nOnly works if channels have `allow_self_set` enabled on the backend.\n\nOnly available for Android and iOS.",
          "complexTypes": [],
          "type": "boolean | undefined"
        }
      ],
      "docs": "CapacitorUpdater can be configured with these options:"
    }
  ]
}